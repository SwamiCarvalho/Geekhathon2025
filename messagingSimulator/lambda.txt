import { BedrockRuntimeClient, InvokeModelCommand } from "@aws-sdk/client-bedrock-runtime";
import { DynamoDBClient, ScanCommand } from "@aws-sdk/client-dynamodb";

const bedrockClient = new BedrockRuntimeClient({ region: process.env.AWS_REGION || 'us-east-1' });

export const handler = async (event) => {
  try {
    console.log("Incoming event:", JSON.stringify(event));

    if (event.requestContext?.http?.method === 'OPTIONS' || event.httpMethod === 'OPTIONS') {
      return {
        statusCode: 200,
        body: '',
      };
    }

    const body = JSON.parse(event.body || "{}");
    const message = body.message;
    const sessionId = body.sessionId || `session-${Date.now()}`;

    if (!message) {
      return {
        statusCode: 400,
        body: JSON.stringify({ error: 'Message is required' }),
      };
    }

    // Bedrock prompt for bus booking extraction
    const prompt = `Extract bus booking information from this user message and return ONLY a valid JSON object.

User message: "${message}"

Extract these fields:
- origin: departure location (exact text from message)
- closest_station: (should be the origin)
- destination: arrival location (exact text from message)  
- time: departure time (exact text from message)
- date: travel date (exact text from message)

If any field is not mentioned, use "not specified".

Return only the JSON object, no other text:`;

    const command = new InvokeModelCommand({
      modelId: "anthropic.claude-3-haiku-20240307-v1:0",
      body: JSON.stringify({
        anthropic_version: "bedrock-2023-05-31",
        max_tokens: 200,
        messages: [{ role: "user", content: prompt }]
      }),
      contentType: "application/json",
      accept: "application/json"
    });

    const response = await bedrockClient.send(command);
    const responseBody = JSON.parse(new TextDecoder().decode(response.body));
    
    console.log("Bedrock response:", responseBody);

    // Parse Claude's response
    let parsedData;
    try {
      const content = responseBody.content[0].text;
      const jsonMatch = content.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        parsedData = JSON.parse(jsonMatch[0]);
      } else {
        throw new Error("No JSON found in response");
      }
    } catch (err) {
      console.error("Failed to parse Bedrock response:", err);
      parsedData = { 
        origin: "not specified", 
        destination: "not specified", 
        time: "not specified", 
        date: "not specified" 
      };
    }

    // Cliente DynamoDB
    const dynamoClient = new DynamoDBClient({ region: process.env.AWS_REGION });

    // Funci칩n auxiliar para calcular distancia haversine (en km)
    function haversine(lat1, lon1, lat2, lon2) {
      const R = 6371; // radio Tierra en km
      const toRad = (deg) => deg * Math.PI / 180;
      const dLat = toRad(lat2 - lat1);
      const dLon = toRad(lon2 - lon1);
      const a =
        Math.sin(dLat / 2) ** 2 +
        Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
        Math.sin(dLon / 2) ** 2;
      return R * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }    

    try {
      // 1. Obtener coordenadas del origin_location usando Nominatim (OSM)
      const nominatimUrl = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(parsedData.origin)}&limit=1`;

      const locationResp = await fetch(nominatimUrl, {
        headers: {
          "User-Agent": "mi-lambda/1.0 (tu-email@ejemplo.com)"  // Nominatim requiere un User-Agent identificable
        }
      });

      const locationData = await locationResp.json();

      if (!locationData || locationData.length === 0) {
        throw new Error("No se encontraron coordenadas para el origin_location");
      }

      const lat = parseFloat(locationData[0].lat);
      const lon = parseFloat(locationData[0].lon);    
      
      // 2. Obtener todas las paradas desde DynamoDB
      const stopsResp = await dynamoClient.send(new ScanCommand({
        TableName: "stops"
      }));
    
      // 3. Calcular la parada m치s cercana
      let closest = null;
      let minDist = Infinity;
    
      for (const item of stopsResp.Items) {
        const stopLat = parseFloat(item.stop_lat.S);
        const stopLon = parseFloat(item.stop_lon.S);
        const dist = haversine(lat, lon, stopLat, stopLon);
    
        if (dist < minDist) {
          minDist = dist;
          closest = {
            name: item.stop_name.S,
            stop_lat: stopLat,
            stop_lon: stopLon,
            distance_km: dist
          };
        }
      }
    
      // 4. Guardar en el JSON
      parsedData["closest_station"] = closest.name;
    
    } catch (err) {
      console.error("Error buscando la estaci칩n m치s cercana:", err);
      parsedData["closest_station"] = err.message;
    }

    // Return in same format as Lex for compatibility
    return {
      statusCode: 200,
      body: JSON.stringify({ 
        transcript: message, 
        lexResponse: { parsedData }
      }),
    };

  } catch (err) {
    console.error("Lambda error:", err);
    return {
      statusCode: 500,
      body: JSON.stringify({ error: err.message, message: "Failed in the catch" }),
    };
  }
};